<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 分别基于TCP和UDP的Socketd的简单实现]]></title>
    <url>%2F2017%2F12%2F23%2Fjava-%E5%88%86%E5%88%AB%E5%9F%BA%E4%BA%8ETCP%E5%92%8CUDP%E7%9A%84Socket%2F</url>
    <content type="text"><![CDATA[Socket百度百科 协议TCP/IP百度百科 Socket实现（教材P348）客户端(1)建立客户端Socket连接。 (2)得到Socket的输入与输出读写流。 (3)使用读写流与服务器进行通信。 (4)关闭流。 (5)关闭Socket。 服务器(1)建立一个ServerSocket并进行监听。 (2)使用accept()方法获取新的连接。 (3)得到Socket的输入与输出读写流。 (4)根据客户端的请求，在已有协议上进行会话。 (5)关闭Socket,关闭TCP连接。 (6)回到第(2)步进行监听，或到第(7)步结束。 (7)关闭ServerSocket。 主要使用的方法和类服务器1234567class ServerSocket (java.net); //ServerSocket类public ServerSocket(int port ) //Server的构造方法public Socket accept() //构造Socket的方法class Socket(java.net); //Socket类public OutputStream getOutputStream() //得到输出流public InputStream getInputStream() //得到输入流 客户端1234class Socket (java.net); //Socket类public Socket(String host, int port) //Socket的构造方法 public OutputStream getOutputStream() //得到输出流public InputStream getInputStream() //得到输入流 实例功能客户端输入三角形三边长传到服务器，服务器计算面积返回到客户端。 截图 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//服务器import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.regex.Pattern;public class Server &#123; ServerSocket server = null; Socket socket = null; int i = 0; public static void main(String[] args) &#123; Server server = new Server(); server.server(); &#125; public void server() &#123; try &#123; server = new ServerSocket(1081);// 建立 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (true) &#123; try &#123; socket = server.accept();// 等待客户端连接 &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; new Mythread(socket, i + "").start();// 若有客户端连接则则创建线程并执行 &#125; // 若运行完会自动关闭 &#125;&#125;class Mythread extends Thread &#123; OutputStream os = null; InputStream is = null; BufferedReader br = null; InputStreamReader isr = null; private Socket socket; public Mythread(Socket socket, String name) &#123; super(name); this.socket = socket; &#125; public void run() &#123; try &#123; is = socket.getInputStream();// 接收流连接 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; isr = new InputStreamReader(is); br = new BufferedReader(isr); String a1 = null; String b1 = null; String c1 = null; try &#123; a1 = br.readLine(); b1 = br.readLine(); c1 = br.readLine(); System.out.println(a1); System.out.println(b1); System.out.println(c1); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; Pattern pattern = Pattern.compile("^\\d+(\\.)?\\d*");// 正则表达式判断输入是否为浮点数字 if (pattern.matcher(a1).matches() &amp;&amp; pattern.matcher(b1).matches() &amp;&amp; pattern.matcher(c1).matches()) &#123; float a = Float.valueOf(a1); float b = Float.valueOf(b1); float c = Float.valueOf(c1); String area = String.valueOf(Math.pow( ((a + b + c) * 0.5 * ((a + b + c) * 0.5 - a) * ((a + b + c) * 0.5 - b) * ((a + b + c) * 0.5 - c)), 0.5)) + "\n"; System.out.println(area); try &#123; os = socket.getOutputStream();// 发送流连接 os.write(area.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; else &#123; try &#123; os = socket.getOutputStream(); os.write("请输入数字".getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; br.close();// 关闭该次连接 isr.close(); is.close(); os.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131//客户端import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.net.Socket;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTextArea;public class Client &#123; Socket socket = null; OutputStream os = null;// 发送用流 InputStream is = null;// 接收用流 public static void main(String[] args) &#123; Client cl = new Client(); cl.gui(); &#125; private void gui() &#123; JFrame jf = new JFrame("三角形面积"); JPanel jp = new JPanel(); JButton conn = new JButton("链接服务器"); JButton count = new JButton("计算"); JLabel a_l = new JLabel("边A:"); JTextArea a_t = new JTextArea(); JLabel b_l = new JLabel("边B:"); JTextArea b_t = new JTextArea(); JLabel c_l = new JLabel("边C:"); JTextArea c_t = new JTextArea(); JLabel g_l = new JLabel("三角形面积："); JTextArea g_t = new JTextArea(); g_t.setBounds(0, 0, 500, 270); JScrollPane jsp = new JScrollPane(g_t); conn.setBounds(100, 20, 100, 30); count.setBounds(300, 20, 100, 30); a_l.setBounds(50, 100, 30, 30); a_t.setBounds(80, 100, 360, 30); b_l.setBounds(50, 150, 30, 30); b_t.setBounds(80, 150, 360, 30); c_l.setBounds(50, 200, 30, 30); c_t.setBounds(80, 200, 360, 30); g_l.setBounds(0, 270, 100, 30); g_t.setBounds(0, 0, 500, 270); conn.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent arg0) &#123; try &#123; socket = new Socket("127.0.0.1", 1081);// 建立 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); count.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent arg0) &#123; String a1 = a_t.getText() + "\n"; String b1 = b_t.getText() + "\n"; String c1 = c_t.getText(); try &#123; os = socket.getOutputStream();// 发送用流连接 os.write(a1.getBytes()); os.write(b1.getBytes()); os.write(c1.getBytes()); socket.shutdownOutput();// 关闭发送流连接 is = socket.getInputStream();// 接收用流连接 InputStreamReader isr = new InputStreamReader(is); BufferedReader bf = new BufferedReader(isr); String area = null; if ((area = bf.readLine()) != null) &#123; if (g_t.getText().equals("")) &#123; g_t.setText(area); &#125; else g_t.setText(g_t.getText() + "\n" + area); &#125; os.close();// 关闭 bf.close(); isr.close(); is.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); jp.setBounds(0, 0, 500, 300); jp.setLayout(null); jp.add(conn); jp.add(count); jp.add(a_l); jp.add(a_t); jp.add(b_l); jp.add(b_t); jp.add(c_l); jp.add(c_t); jp.add(g_l); jsp.setBounds(0, 300, 500, 170); jf.setSize(500, 500); jf.setLocationRelativeTo(null); jf.setLayout(null); jf.add(jp); jf.add(jsp); jf.setResizable(false); jf.setVisible(true); jf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); &#125;&#125; UDP百度百科 Socket实现(教材352)发送端(1)创建套接字(Socket)(2)发送数据(send)(3)关闭套接字 接收端(1)创建套接字(Socket)。 (2)将套接字绑定到一个本地地址和端口上(blind)。 (3)等待接收数据(receive)。 (4)关闭套接字。 主要使用的方法和类接收12345678class DatagramSocket //类public DatagramPacket(byte buf[], int length) //构造方法revice(DatagramPacket) //接收信息class DatagramPacket //类public void DatagramPacket(byte[ ] buf,int length); public void DatagramPacket(byte[ ] buf, int offset, int length)；public void DatagramPacket(byte[ ] data, int length, InetAddress addr, int port);//构造方法 发送12345678910class DatagramSocket; //类public DatagramSocket(int port)//构造方法send(DatagramPacket); //发送信息class DatagramPacket; //类public void DatagramPacket(byte[ ] data, int offset, int length, InetAddress address, int port)；public void DatagramPacket(byte[ ] data, int length, InetAddress address, int port)；//构造方法 实例功能客户端接收字符串传到服务器，服务器把字符串变成大写传到客户端 截图 代码1234567891011121314151617181920212223242526272829303132333435363738394041//服务器import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;public class Server &#123; private DatagramSocket socket = null; public static void main(String[] args) &#123; Server server = new Server(); server.server(); &#125; public void server() &#123; byte[] buf = new byte[2048]; DatagramPacket packet_r = new DatagramPacket(buf, 2048);//接收用packet try &#123; socket = new DatagramSocket(1081); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; try &#123; socket.receive(packet_r);//接收 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String info = new String(packet_r.getData(), 0, packet_r.getLength());//转换成字符串 System.out.println(info); info=info.toUpperCase();//转成大写 System.out.println(info); DatagramPacket packet_s = new DatagramPacket(info.getBytes(), info.getBytes().length, packet_r.getAddress(), packet_r.getPort());//发送用packet try &#123; socket.send(packet_s);//发送 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; socket.close();//关闭 &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//客户端import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetAddress;import java.net.SocketException;import java.net.UnknownHostException;public class Client &#123; public static void main(String[] args) &#123; Client client = new Client(); client.client(); &#125; public void client() &#123; System.out.println("输入需要转换的字符串"); InputStreamReader is = new InputStreamReader(System.in); BufferedReader br = new BufferedReader(is); String a = null; try &#123; a = br.readLine(); &#125; catch (IOException e2) &#123; e2.printStackTrace(); &#125; // 获取键盘输入 DatagramPacket packet_s = null;// 要发送的数据 DatagramPacket packet_r = null;// 接收数据的packet DatagramSocket socket = null;// socket try &#123; socket = new DatagramSocket(1082); &#125; catch (SocketException e1) &#123; e1.printStackTrace(); &#125; try &#123; packet_s = new DatagramPacket(a.getBytes(), a.getBytes().length, InetAddress.getByName("127.0.0.1"), 1081);// 发送的packet包括要发送的数据，数据长度，目标地址，目标端口 &#125; catch (UnknownHostException e) &#123; e.printStackTrace(); &#125; try &#123; socket.send(packet_s);//发送 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; byte[] buf = new byte[2048]; packet_r = new DatagramPacket(buf, 2048);//接收用packet try &#123; socket.receive(packet_r);//接收 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; String info = new String(packet_r.getData(), 0, packet_r.getData().length);//转换成字符串 System.out.println(info); socket.close();//关闭 &#125;&#125; 基于TCP的Socket和基于UDP的Socket对比TCP是面向连接的协议，适合于对可靠性要求高的运行环境，TCP是严格的安全的。UDP是非连续连接的通讯协议，是一钟面向无连接的协议。UDP不保证数据能够正确抵达目标,无法保证数据安全传送，多个数据包抵达目标的顺序可能和发送时顺序不同，但比它TCP更轻。也就是一般来说TCP比UDP稳定安全，UDP比TCP快速,TCP适用需要稳定安全的环境，UDP适用对稳定安全要求不大，对速度要求较高的环境。]]></content>
      <categories>
        <category>Java学习笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
        <tag>多线程</tag>
        <tag>Socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[request.getRequestDispatcher().forward(,)后代码继续执行]]></title>
    <url>%2F2017%2F12%2F02%2Frequest-getRequestDispatcher-forward-%E5%90%8E%E4%BB%A3%E7%A0%81%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[request.getRequestDispatcher().forward(,)后别忘了后面的代码。： 在执行如上代码输入密码为111111的时候发现程序进了if(a)条件语句并在页面中显示“密码不能所有位数均相同” 但还是创建了账号保存在数据库中。 于是认为在执行完if(a)判断且进入执行里面的语句1request.getRequestDispatcher(&quot;counter.jsp&quot;).forward(request, response); 后，Servlet后面的代码仍会执行（执行了ins.Ins(user)以致创建了账号保存在数据库中）。 于是我给添加语句ins.Ins(user)加了一个if(!a)判断密码相同时不执行添加语句，问题解决，在输入密码格式错误时出现错误提示且没有执行添加的语句ins.Ins(user)。 在百度搜索后发现，确实Servlet在执行request.getRequestDispatcher().forward(,)后，后面的代码仍然会继续执行，且无论是request.getRequestDispatcher(path).forward(request, response)还是response.sendRedirect,程序都会在执行完该句的情况下继续向下执行。链接 当然后面出现的转发代码不会被执行，而是出现异常 java.lang.IllegalStateException: Cannot forward after response has been committed 如:]]></content>
      <categories>
        <category>Web学习笔记</category>
      </categories>
      <tags>
        <tag>Jsp</tag>
        <tag>Servlet</tag>
        <tag>跳转</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Visio制作ER图学习笔记]]></title>
    <url>%2F2017%2F11%2F29%2FVisio%E5%88%B6%E4%BD%9CER%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[E-R图E-R图全称实体-联系图(Entity RelationshipDiagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 百度百科 在建立复杂的数据库前，我们一般需要先建立一个模型以直观的展示自己的数据库设计来方便整理思路并能通过模型较为方便地分析自己的数据库是否合理。 使用Visio使用Visio2010来建立E-R图 选择软件和数据库,选择创建数据库模型图 拖动实体到绘图页面 选择拖动到绘图页面的实体框在坐下角选择定义，输入表名 输入表明后后点击列输入列名与列的数据类型选择是否必要是否为PK； 通过同样方法建其它表通过关系来创建表之间的关系 : : Ps:关于可移植数据类型和物理数据类型之间的选择以及驱动程序选项 在数据库模型图中设置和编辑数据类型]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>ER图</tag>
        <tag>Visio</tag>
        <tag>数据库设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下GitHub Pages+Hexo搭建博客]]></title>
    <url>%2F2017%2F11%2F29%2FGitHub-Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[#GitHub pages 先新建一个repository Repository name填GitHub名字.github.io如(weiboboCN.github.io） 选择setting 往下拉找到GitHub Pages 选择choose a theme选择自动生成的主页的样式选择一个主题后提交 至此一个初步的主页已经形成. 在浏览器输入weiboboCN.github.io即可进入自己最初的主页 主页文件为index.md 可以选着自己敲一个主页换掉index.md或者选择使用功能强大的工具Hexo来制作自己的主页 安装Hexo安装Hexo前需要安装Node.jsNode.js1$ sudo apt-get install nodejs npm1$ sudo apt-get install npm 安装Hexo1$ sudo npm install hexo-cli -g Hexo安装完成用Hexo建一个博客12$ Hexo init blog //创建一个博客放在blog文件夹$ npm install //安装依赖包 Hexo静态博客搭建+个人定制 Linux下使用Hexo搭建github博客 本地页面在根目录（blog）使用命令1$ hexo server 运行后在浏览器输入地址1http://localhost:4000/ 即可浏览博客 把本地调整好的博客传到GitHub上修改根目录的_config.yml最后面的deploy里面的代码，其中yourname改为你的GitHub的名字（冒号和后面的值之间要有一个空格，很重要如type: git //不能为type:git）1234deploy: type: git repo: https://github.com/yourname/yourname.github.io.git branch: master 安装hexo-deployer-git使其能发布到GitHub上 参考 1$ npm install hexo-deployer-git --save 使用hexo d -g即可把本地的博客传到GitHub上1hexo d -g Done! Ps: hexo的基本使用和主题更换 hexo的使用文档 我使用的next主题 next主题的使用文档]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
</search>
